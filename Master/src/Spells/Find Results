Searching 80 files for "Manager" (case sensitive, whole word)

0 matches

Searching 80 files for "Manager"

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Game.cpp:
    5  
    6  Game::Game(){
    7: 	masterSpell 	= ManagerSpell::GetInstance();
    8: 	masterBullet 	= ManagerBullet::GetInstance();
    9: 	masterEffect 	= ManagerEffect::GetInstance();
   10: 	masterObject	= ManagerObject::GetInstance();
   11: 	masterPlayer	= ManagerPlayer::GetInstance();
   12: 	masterTrap		= ManagerTrap::GetInstance();
   13  
   14  	f_engine = BulletEngine::GetInstance();
   ..
   64  	}
   65  	if(g_engine->IsLeftButtonPressed()){ 
   66: 		ManagerSpell::GetInstance()->ResetHechizo(0,playerOne);
   67  		playerOne->DropObject();
   68  	}
   69  	if(g_engine->IsLeftButtonDown()){  
   70: 		ManagerSpell::GetInstance()->LanzarHechizo(0,playerOne); 
   71  	}
   72  	if(g_engine->IsKeyPressed(KEY_KEY_E)){ 
   73: 		ManagerSpell::GetInstance()->LanzarHechizo(1,playerOne);
   74  		playerOne->Raycast(); 
   75  	}

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Game.h:
    6  #include "./Player.h"
    7  
    8: #include "./ManagerSpell.h"
    9: #include "./ManagerBullet.h"
   10: #include "./ManagerEffect.h"
   11: #include "./ManagerObject.h"
   12: #include "./ManagerPlayer.h"
   13: #include "./ManagerTrap.h"
   14  //Fachada
   15  #include "PhysicsEngine/BulletEngine.h"
   ..
   37  	float deltaTime;
   38  
   39: 	ManagerSpell* 		masterSpell;
   40: 	ManagerBullet* 		masterBullet;
   41: 	ManagerEffect* 		masterEffect;
   42: 	ManagerObject*		masterObject;
   43: 	ManagerPlayer*		masterPlayer;
   44: 	ManagerTrap*		masterTrap;
   45  
   46  	GraphicEngine*		g_engine;

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Player.cpp:
    1  #include "./Player.h"
    2  #include "./PhysicsEngine/BulletEngine.h"
    3: #include "./ManagerObject.h"
    4: #include "./ManagerTrap.h"
    5  
    6  #include "./Objects/Potion.h"
    .
  205  	if(potion!=NULL){
  206  		potion->Use(this);
  207: 		ManagerObject::GetInstance()->DeletePotion(potion);
  208  		potion = NULL;
  209  	}
  ...
  222  	vector3df End(EndX, EndY, EndZ);
  223  
  224: 	ManagerTrap::GetInstance()->AddTrap(End,TENUM_DEATH_CLAWS);
  225  }
  226  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Trap.cpp:
    1  #include "Trap.h"
    2: #include "./ManagerTrap.h"
    3  #include "Game.h"
    4  
    .
   92      }
   93      if(tipo == EENUM_PROJECTILE){
   94:         ManagerTrap::GetInstance()->DeleteTrap(this);
   95      }
   96  }
   ..
  107  
  108      player->Respawn();
  109:     ManagerTrap::GetInstance()->DeleteTrap(this);
  110      
  111  }
  ...
  121  
  122  	if(m_current_time>=m_deactivation_time){
  123: 		ManagerTrap::GetInstance()->DeleteTrap(this);
  124  		m_current_time=0.0f;
  125  	}

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/main.cpp:
   10  //Controlers
   11  #include "Game.h"
   12: #include "ManagerObject.h"
   13  
   14  void createScenery(){
   15: 	ManagerObject* objman = ManagerObject::GetInstance(); 
   16  
   17  	vector3df TPosition(0,-1,0);
   ..
   80  	}
   81  	if(engine->IsLeftButtonPressed()){ 
   82: 		ManagerSpell::GetInstance()->ResetHechizo(0,physicPlayer);
   83  		physicPlayer->DropObject();
   84  	}
   85: 	if(engine->IsLeftButtonDown()){  ManagerSpell::GetInstance()->LanzarHechizo(0,physicPlayer); 
   86  	}
   87: 	if(engine->IsKeyPressed(KEY_KEY_E)){ ManagerSpell::GetInstance()->LanzarHechizo(1,physicPlayer);
   88  	physicPlayer->Raycast(); }
   89  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Bullets/Proyectil.cpp:
    1  #include "Proyectil.h"
    2: #include "./../Managers/ManagerBullet.h"
    3  #include "./../Player.h"
    4  
    .
   64  
   65      if(currentDistance >= maxDistance){
   66:         ManagerBullet* c = ManagerBullet::GetInstance();
   67          c->AddToDeleteProyecil(this);
   68      }
   ..
   80          p->ChangeHP(-25.0f);
   81      }
   82:     ManagerBullet* c = ManagerBullet::GetInstance();
   83      c->AddToDeleteProyecil(this);
   84  }

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/GraphicEngine/GraphicEngine.cpp:
   26  
   27      privateDriver = privateDevice->getVideoDriver();
   28:     privateSManager = privateDevice->getSceneManager();
   29      privateGUIEnv = privateDevice->getGUIEnvironment();
   30  }
   ..
   97  }
   98  
   99: // SMANAGER FUNCTIONS
  100  void GraphicEngine::drawAll(){
  101:     privateSManager->drawAll();
  102  }
  103  
  104  GBody* GraphicEngine::addCube2Scene(vector3df p, vector3df r, vector3df s, float size, int id){
  105      return new GBody(
  106:         privateSManager->addCubeSceneNode(
  107              size,   //size
  108              0,      //parent
  ...
  116  GBody* GraphicEngine::addSphere2Scene(vector3df p, vector3df r, vector3df s, float radius, int id){
  117      return new GBody(
  118:         privateSManager->addSphereSceneNode(
  119              radius,     //size
  120              16,         //polycount
  ...
  128  
  129  GBody* GraphicEngine::addObjMeshSceneNode(std::string path){
  130:     return new GBody(privateSManager->addAnimatedMeshSceneNode(privateSManager->getMesh(path.c_str())));
  131  }
  132  
  133  void GraphicEngine::setAnimationFlyStraight(GBody* body, vector3df initialPos, vector3df finalPos, float time, bool loop, bool pingpong){
  134:     irr::scene::ISceneNodeAnimator* anim = privateSManager->createFlyStraightAnimator(
  135          irr::core::vector3df(initialPos.X, initialPos.Y, initialPos.Z), 
  136          irr::core::vector3df(  finalPos.X,   finalPos.Y,   finalPos.Z), 
  ...
  147  
  148  GCamera* GraphicEngine::addCameraSceneNodeFPS(float rotateSpeed, float moveSpeed){
  149:     privateCamera = new GCamera(privateSManager->addCameraSceneNodeFPS(0, rotateSpeed, moveSpeed));
  150      return privateCamera;
  151  }
  152  
  153  GCamera* GraphicEngine::getActiveCamera(){
  154:     privateCamera->privateNode = privateSManager->getActiveCamera();
  155      return privateCamera;
  156  }
  157  
  158  void GraphicEngine::addToDeletionQueue(irr::scene::ISceneNode* g){
  159:     privateSManager->addToDeletionQueue(g);
  160  }
  161  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/GraphicEngine/GraphicEngine.h:
   72      void drawAim();
   73  
   74:     /// SMANAGER FUNCTIONS
   75  
   76      /**
   ..
  208      irr::IrrlichtDevice*        privateDevice;
  209      irr::video::IVideoDriver*   privateDriver;
  210:     irr::scene::ISceneManager*  privateSManager;
  211      irr::gui::IGUIEnvironment*  privateGUIEnv;
  212      EventReceiver* privateReceiver;

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerBullet.cpp:
    1: #include "ManagerBullet.h"
    2  
    3: ManagerBullet* ManagerBullet::instance = 0;
    4  
    5: ManagerBullet::ManagerBullet(){}
    6  
    7: ManagerBullet::~ManagerBullet(){
    8  	DeleteAllProyectiles();
    9  }
   10  
   11: ManagerBullet* ManagerBullet::GetInstance(){
   12  	if(instance==0){
   13: 		instance = new ManagerBullet();
   14  	}
   15  	return instance;
   16  }
   17  
   18: void ManagerBullet::AddProyectil(vector3df pos, vector3df dir, float r, float v, BULLETCODE b){
   19  	switch(b){
   20  		case BULLET_BASIC:
   ..
   24  }
   25  
   26: void ManagerBullet::Update(){
   27  	DeleteProyectiles();
   28  	int size = proyectiles.size();
   ..
   36   * @details [long description]
   37   */
   38: void ManagerBullet::AddToDeleteProyecil(Proyectil* pro){
   39  	// Comprueba que el proyectil no sea NULL
   40  	if(pro!=NULL){
   ..
   60   * @details [long description]
   61   */
   62: void ManagerBullet::DeleteProyectiles(){
   63  	// Nos guardamos el tamanyo del vector
   64  	int size = proyectilesToDelete.size();
   ..
   75  }
   76  
   77: void ManagerBullet::DeleteAllProyectiles(){
   78  	// =====================================
   79  	//  PROYECTILES

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerBullet.h:
    1: #ifndef MANAGERBULLET_H
    2: #define MANAGERBULLET_H
    3  
    4  #include <vector>
    .
   11  #include "GraphicEngine/GraphicEngine.h"
   12  
   13: class ManagerBullet{
   14  public:
   15: 	static ManagerBullet* GetInstance();
   16: 	~ManagerBullet();
   17  
   18  	void AddProyectil(vector3df pos, vector3df dir, float r, float v, BULLETCODE b);
   ..
   26  	vector<Proyectil*> proyectilesToDelete;
   27  
   28: 	ManagerBullet();
   29: 	static ManagerBullet* instance;
   30  };
   31  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerEffect.cpp:
    1: #include "ManagerEffect.h"
    2  #include "./Game.h"
    3  
    4: ManagerEffect* ManagerEffect::instance = 0;
    5  
    6: ManagerEffect::ManagerEffect(){
    7  	maxTime = 0.5f;
    8  	currentTime = 0.0f;
    9  }
   10  
   11: ManagerEffect::~ManagerEffect(){
   12  	std::map<Player*,vector<Effect*>* >::iterator it = effects.begin();
   13  	for(; it != effects.end(); ++it){				// Recorremos entre todos los efectos
   ..
   23  }
   24  
   25: ManagerEffect* ManagerEffect::GetInstance(){
   26  	if(instance==0){
   27: 		instance = new ManagerEffect();
   28  	}
   29  	return instance;
   30  }
   31  
   32: void ManagerEffect::AddEffect(Player* p, EFFECTCODE EFFECT){
   33  	std::map<Player*, vector<Effect*>* >::iterator it;
   34  	it = effects.find(p);
   ..
   42  }
   43  
   44: void ManagerEffect::UpdateEffects(){
   45  	float deltaTime = Game::GetInstance()->GetDeltaTime();
   46  	currentTime += deltaTime;
   ..
   68  }
   69  
   70: Effect* ManagerEffect::CreateEffect(EFFECTCODE EFFECT){
   71  	Effect * e;
   72  	switch(EFFECT){

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerEffect.h:
    1: #ifndef MANAGEREFFECT_H
    2: #define MANAGEREFFECT_H
    3  
    4  #include <iostream>
    .
   12  #include "./Effects/EffectCodes.h"
   13  
   14: class ManagerEffect{
   15  public:
   16: 	static ManagerEffect* GetInstance();
   17: 	~ManagerEffect();
   18  
   19  	void AddEffect(Player* p, EFFECTCODE e);
   ..
   27  	float maxTime;
   28  
   29: 	ManagerEffect();
   30: 	static ManagerEffect* instance;
   31  };
   32  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerObject.cpp:
    1: #include "ManagerObject.h"
    2  
    3: ManagerObject* ManagerObject::instance = 0;
    4  
    5: ManagerObject::ManagerObject(){
    6  	grail = NULL;
    7  }
    8  
    9: ManagerObject::~ManagerObject(){
   10  	int size = blocks.size();
   11  	for(int i=0; i<size; i++){
   ..
   46  }
   47  
   48: ManagerObject* ManagerObject::GetInstance(){
   49  	if(instance==0){
   50: 		instance = new ManagerObject();
   51  	}
   52  	return instance;
   53  }
   54  
   55: Block* ManagerObject::AddBlock(vector3df pos, vector3df size, vector3df rot, int texture){
   56  	Block* b = new Block(pos, rot, size, texture);
   57  	blocks.push_back(b);
   ..
   59  }
   60  
   61: Door* ManagerObject::AddDoor(){
   62  	Door* d = new Door();
   63  	doors.push_back(d);
   ..
   65  }
   66  
   67: Grail* ManagerObject::AddGrail(){
   68  	if(grail==NULL){
   69  		grail = new Grail();
   ..
   72  }
   73  
   74: Switch* ManagerObject::AddSwitch(Door* d){
   75  	Switch* s = new Switch();
   76  	s->SetDoor(d);
   ..
   79  }
   80  
   81: Potion* ManagerObject::AddPotion(vector3df pos){
   82  	Potion* p = new Potion(pos);
   83  	potions.push_back(p);
   ..
   85  }
   86  
   87: Fountain* ManagerObject::AddFountain(){
   88  	Fountain* f = new Fountain();
   89  	fountains.push_back(f);
   ..
   91  }
   92  
   93: void ManagerObject::DeletePotion(Potion* potion){
   94  	int size = potions.size();
   95  	for(int i=0; i<size; i++){
   ..
  102  }
  103  
  104: void ManagerObject::Update(){
  105  	UpdateGrail();
  106  	UpdateDoors();
  ...
  111  }
  112  
  113: void ManagerObject::UpdateGrail(){
  114  	if(grail!=NULL){
  115  		grail->Update();
  ...
  117  }
  118  
  119: void ManagerObject::UpdateDoors(){
  120  	int size = doors.size();
  121  	for(int i=0; i<size; i++){
  ...
  125  }
  126  
  127: void ManagerObject::UpdateSwitchs(){
  128  	int size = switchs.size();
  129  	for(int i=0; i<size; i++){
  ...
  133  }
  134  
  135: void ManagerObject::UpdatePotions(){
  136  	int size = potions.size();
  137  	for(int i=0; i<size; i++){
  ...
  141  }
  142  
  143: void ManagerObject::UpdateFountains(){
  144  	int size = fountains.size();
  145  	for(int i=0; i<size; i++){
  ...
  149  }
  150  
  151: void ManagerObject::UpdateBlocks(){
  152  	int size = blocks.size();
  153  	for(int i=0; i<size; i++){

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerObject.h:
    1: #ifndef MANAGEROBJECT_H
    2: #define MANAGEROBJECT_H
    3  
    4  #include <iostream>
    .
   12  #include "./Objects/Grail.h"
   13  
   14: class ManagerObject{
   15  public:
   16: 	static ManagerObject* GetInstance();
   17: 	~ManagerObject();
   18  
   19  	// Create Block and adds to vector
   ..
   41  	Grail*				grail;
   42  
   43: 	ManagerObject();
   44: 	static ManagerObject* instance; 
   45  };
   46  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerPlayer.cpp:
    1: #include "ManagerPlayer.h"
    2  
    3: ManagerPlayer* ManagerPlayer::instance = 0;
    4  
    5: ManagerPlayer* ManagerPlayer::GetInstance(){
    6  	if(instance==0){
    7: 		instance = new ManagerPlayer();
    8  	}
    9  	return instance;
   10  }
   11  
   12: ManagerPlayer::ManagerPlayer(){}
   13  
   14: ManagerPlayer::~ManagerPlayer(){
   15  	int size = players.size();
   16  	for(int i=0; i<size; i++){
   ..
   21  }
   22  
   23: Player* ManagerPlayer::AddPlayer(bool one){
   24  	Player* p = new Player(one);
   25  	players.push_back(p);
   ..
   27  }
   28  
   29: void ManagerPlayer::UpdatePlayers(){
   30  	int size = players.size();
   31  	for(int i=0; i<size; i++){

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerPlayer.h:
    1: #ifndef MANAGERPLAYER_H
    2: #define MANAGERPLAYER_H
    3  
    4  #include <iostream>
    .
    7  #include "Player.h"
    8  
    9: class ManagerPlayer{
   10  public:
   11: 	static ManagerPlayer* GetInstance();
   12: 	~ManagerPlayer();
   13  
   14  	Player* AddPlayer(bool);
   ..
   18  	vector<Player*>	players;
   19  
   20: 	ManagerPlayer();
   21: 	static ManagerPlayer* instance;
   22  };
   23  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerSpell.cpp:
    1: #include "ManagerSpell.h"
    2  #include "./GraphicEngine/GraphicEngine.h"
    3  #include "./Game.h"
    4  
    5  
    6: ManagerSpell* ManagerSpell::instance = 0;
    7  
    8: ManagerSpell::ManagerSpell(){
    9  }
   10  
   11: ManagerSpell::~ManagerSpell(){
   12  	for(int i=0; i<numHechizos; i++){
   13  		std::map<Player*, Hechizo*>::iterator it = hechizos[i].begin();
   ..
   20  }
   21  
   22: ManagerSpell* ManagerSpell::GetInstance(){
   23  	if(instance==0){
   24: 		instance = new ManagerSpell();
   25  	}
   26  	return instance;
   ..
   36   * @return 		[Se ha asignado correctamente el hechizo]
   37   */
   38: bool ManagerSpell::AddHechizo(int num, Player* p, SPELLCODE type){
   39  	if(num>=0 && num<numHechizos){				// Comprobamos si el numero de hechizo pasado es correcto
   40  		Hechizo* h = hechizos[num][p];			// Nos guardamos el hechizo que habia antes guardado
   ..
   52   * @details [long description]
   53   */
   54: void ManagerSpell::UpdateCooldown(){
   55  	float deltaTime = Game::GetInstance()->GetDeltaTime();
   56  
   ..
   66  }
   67  
   68: bool ManagerSpell::LanzarHechizo(int num, Player* p){
   69  	if(num>=0 && num<numHechizos){				// Comprobamos si el numero de hechizo pasado es correcto
   70  		Hechizo* h = hechizos[num][p];			// Cargamos el hechizo en una variables
   ..
   80  }
   81  
   82: void ManagerSpell::ResetHechizo(int num, Player* p){
   83  	if(num>=0 && num<numHechizos){				// Comprobamos si el numero de hechizo pasado es correcto
   84  		Hechizo* h = hechizos[num][p];			// Cargamos el hechizo en una variables
   ..
   92  }
   93  
   94: Hechizo* ManagerSpell::CrearHechizo(SPELLCODE type){
   95  	Hechizo* h;
   96  	switch(type){

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerSpell.h:
    1: #ifndef MANAGERSPELL_H
    2: #define MANAGERSPELL_H
    3  
    4  #include <iostream>
    .
    9  #include "Player.h"
   10  
   11: class ManagerSpell{
   12  public:
   13: 	static ManagerSpell* GetInstance();
   14: 	~ManagerSpell();
   15  
   16  	bool AddHechizo(int num, Player* p, SPELLCODE type);
   ..
   25  	int numHechizos = 4;
   26  
   27: 	ManagerSpell();
   28: 	static ManagerSpell* instance;
   29  };
   30  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerTrap.cpp:
    1: #include "ManagerTrap.h"
    2  
    3: ManagerTrap* ManagerTrap::instance = 0;
    4  
    5: ManagerTrap* ManagerTrap::GetInstance(){
    6  	if(instance==0){
    7: 		instance = new ManagerTrap();
    8  	}
    9  	return instance;
   10  }
   11  
   12: ManagerTrap::ManagerTrap(){}
   13  
   14: ManagerTrap::~ManagerTrap(){
   15  	int size = traps.size();
   16  	for(int i=0; i<size; i++){
   ..
   21  }
   22  
   23: Trap* ManagerTrap::AddTrap(vector3df pos, TrapEnum type){
   24  	Trap* t = new Trap(pos, type);
   25  	traps.push_back(t);
   ..
   27  }
   28  
   29: void ManagerTrap::DeleteTrap(Trap* trap){
   30  	int size = traps.size();
   31  	for(int i=0; i<size; i++){

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Managers/ManagerTrap.h:
    1: #ifndef MANAGERTRAP_H
    2: #define MANAGERTRAP_H
    3  
    4  #include <iostream>
    .
    7  #include "Trap.h"
    8  
    9: class ManagerTrap{
   10  public:
   11: 	static ManagerTrap* GetInstance();
   12: 	~ManagerTrap();
   13  
   14  	void DeleteTrap(Trap* t);
   ..
   17  	vector<Trap*> traps;
   18  
   19: 	ManagerTrap();
   20: 	static ManagerTrap* instance;
   21  };
   22  

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Spells/Hechizo.cpp:
    1  #include "Hechizo.h"
    2: #include "./../ManagerBullet.h"
    3  #include "./../GraphicEngine/GraphicEngine.h"
    4  #include "./../Game.h"

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Spells/HechizoProyectil.cpp:
    1  #include "HechizoProyectil.h"
    2: #include "./../ManagerBullet.h"
    3  
    4  HechizoProyectil::HechizoProyectil(int costPM, float tCast, float tCoolDown):Hechizo(costPM, tCast, tCoolDown){
    .
   21  	pos.Z = pos.Z + cos(rot.Y)*cos(rot.X)*max;
   22  
   23: 	ManagerBullet* c = ManagerBullet::GetInstance();
   24  	c->AddProyectil(pos, vector3df( sin(rot.Y)*cos(rot.X), sin(rot.X), cos(rot.Y)*cos(rot.X)), 0.05f, 10.0f, BULLET_BASIC);
   25  }

192 matches across 22 files


Searching 80 files for "#include "./Manager"

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Game.h:
    6  #include "./Player.h"
    7  
    8: #include "./ManagerSpell.h"
    9: #include "./ManagerBullet.h"
   10: #include "./ManagerEffect.h"
   11: #include "./ManagerObject.h"
   12: #include "./ManagerPlayer.h"
   13: #include "./ManagerTrap.h"
   14  //Fachada
   15  #include "PhysicsEngine/BulletEngine.h"

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Player.cpp:
    1  #include "./Player.h"
    2  #include "./PhysicsEngine/BulletEngine.h"
    3: #include "./ManagerObject.h"
    4: #include "./ManagerTrap.h"
    5  
    6  #include "./Objects/Potion.h"

/home/daniel/Documentos/WizardsAndWarlocks/Master/src/Trap.cpp:
    1  #include "Trap.h"
    2: #include "./ManagerTrap.h"
    3  #include "Game.h"
    4  

9 matches across 3 files
